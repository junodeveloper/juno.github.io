## APIO 2015 - Bali Sculptures

예전에 풀었던거긴 한데 약간 짚고 넘어갈 부분이 있어서 다시 정리해봅니다.

이 문제는 정답 비트를 상위 비트부터 결정해나가는 식으로 풀 수 있습니다. 답의 n번째 비트를 0으로 만들 수 있는지 먼저 보고 (최소화해야 하므로), 만들 수 있다면 0으로 세팅하고 아니면 1로 세팅합니다. 그리고 n-1번째 비트를 보고, n-2, …, 1번째 비트까지 결정하면 답 자체가 결정됩니다. 이 풀이가 올바르다는 것은…자명합니다. (두 수의 비교가 최상위 비트부터 이루어짐을 생각한다면 쉽습니다.)

그러면 결정하는 것을 어떻게 하느냐. 순차적으로, 반복적으로 비트를 결정해나가는 것이기 때문에, 귀납적으로 생각합시다. 현재 i번째 비트를 보고 있다고 생각합시다. 그러면 i+1번째 비트부터 최상위 비트까지는 이미 결정된 상태겠죠? 이제 i번째 비트를 0으로 만들 수 있는지 확인할겁니다.

즉, X개의 구간을 잡았을 때 어느 구간의 합도 i번째 비트를 포함하지 않아야 합니다. 이러한 조건을 만족하는 분할이 존재하는지 판단하는 것이 관건입니다. 구간은 연속하기 때문에 끊어지는 부분만 잘 골라주면 됩니다. 이건 마지막 조각상에서 출발하여 왼쪽으로 X번 뛰어서 첫 번째 조각상에 도착하는 경로로도 생각할 수 있고, 따라서 BFS나 DFS로도 간단하게 판단할 수 있을 것 같네요. 단, 한 번 왼쪽으로 뛸 때 이동 가능한 위치에 제한을 두면 됩니다. 뛰는 위치부터 현재 위치까지의 합이 i번째 비트를 포함하지 않는 경우에만 뛸 수 있는거죠. 그러면 아마 될 것 같습니다.

그런데 사실 아직 고려하지 않은 게 있습니다. i+1번째 비트부터 최상위 비트까지는 사실상 이미 결정된 상태입니다. 만약 해당 비트들 중 0인 비트가 있다면, 그 비트 또한 건드리면 안 됩니다. 이건 위에서와 마찬가지로 이동에 추가적인 제한을 주는 것에 불과하죠. 별 문제가 없습니다.

그런데 1인 비트가 있다면? 1이라는 것은 X개의 구간들 중 '최소' 하나의 구간의 합이 해당 비트에 1로 켜져 있어야 함을 의미합니다. 이런 조건까지 강제하려고 한다면, 알고리즘이 조금 복잡해집니다.

물론 이것을 최대한 최적화해서 구현하려는 시도도 나쁘진 않습니다. 하지만 재미있게도 1인 비트는 신경쓰지 않아도 됩니다. 다시 말해 최소 하나의 구간을 해당 비트에서 1로 설정하려는 노력을 하지 않아도 된다는 겁니다. 왜냐하면, 어차피 그 비트는 반드시 1로 설정될 수밖에 없습니다. 만약에 해당 비트가 0이 되는 해가 존재한다고 칩시다. 그러면, 알고리즘에 따라 애초에 그 비트를 결정할 때 0으로 세팅하는 것이 가능했었고, 1이 아니라 0으로 설정되었어야 합니다. 모순이죠.

따라서 1인 놈들은 신경쓸 필요가 없습니다. 우리는 단지 0인 비트들만 건드리지 않으면 되는겁니다. 이제 위 방법에 따라 BFS를 비트 수만큼 돌리면 문제를 풀 수 있겠네요! ㅇㅅㅇ

