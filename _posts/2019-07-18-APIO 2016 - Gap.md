## APIO 2016 - Gap

인터렉티브 문제입니다. 코포에 나오기 좋을 법한 문제죠. 사실 저는 아이디어를 떠올리기가 어려웠습니다. 그러나 딱히 복잡하지도 않고, 구현은 더욱 쉽습니다.

Subtask1의 경우는 매우 쉽습니다. 맨 앞 수와 맨 뒤 수를 제거해나가는 것이죠. 이건 쉬우니까 패스하겠습니다.

Subtask2는 쿼리의 횟수 뿐 아니라 한 쿼리에 포함된 원소들의 개수까지도 작게 해야합니다. 아무래도 범위가 넓은 쿼리를 날리기는 좀 부담스럽죠. 뭔가 일정한 크기의 구간별로 잘 나눠서 하면 되지 않을까.. 하는 생각을 해볼 수 있습니다. 문제는 구간의 크기와 개수를 얼마로 하느냐입니다.

일단은 [0, 1e18] 구간을 X개의 동일한 크기의 구간들로 쪼개서 쿼리를 날린다고 해봅시다. 그러면 n개의 각 원소가 정확히 한 번씩 카운트되고, 쿼리를 X번 날리니까 M의 값은 n+X가 됩니다.

어쨌든 우리는 M을 3n 이하로 만들어야 하기 때문에, 구간의 개수 X는 대충 n개 언저리로 잡으면 되지 않을까 싶습니다.

사실 여기까지는 단순한 추론일 뿐이고, 이제 실질적으로 X개의 각 구간별로 mn, mx 정보를 바탕으로 답을 구하는 방법을 생각해봅시다. 한 가지 확실한건 인접한 두 구간의 mx와 mn은 원래 수열에서도 인접하다는 겁니다. 좋은 정보군요. 사실 저는 여기서 별로 진전이 없었습니다.

그러면 다른 방향으로 생각해봅시다. n개의 원소들이 쭉 나열되어 있는데, 우리가 구해야 할 건 결국 gap의 최댓값입니다.

우리가 첫 번째 원소와 마지막 원소를 알고 있다고 해보죠. 그러면 여기서 gap의 하한이나 상한에 대한 정보를 알 수 있지 않을까요? 왜냐면, 나머지 n-2개의 원소를 그 사이에 집어넣는다고 생각했을 때, gap 자체는 임의의 값이 될 수 있지만 gap의 최댓값은 뭔가 아주 작아질 수는 없어보입니다. 직관적으로 생각했을 때, n-2개를 균등하게 배치했을 때 gap의 최댓값이 최소가 되겠죠. gap의 하한을 구한 것 같습니다.

그러면 이 하한을 길이로 하는 구간을 쿼리로 날리면 어떨까요? 여기서 중요한 사실은, 한 구간 내에서의 gap은 당연히 하한보다 작거나 같기 때문에 신경 쓸 필요가 없습니다! 인접한 구간 사이의 gap들만이 하한보다 커질 수 있죠. 아주 좋은 정보입니다.

또 좋은 소식은, 하한일 때 길이가 (mx - mn) / (n - 1)을 올림한 값이라는 겁니다. 이게 왜 좋은 소식이냐구요? 구간의 개수가 n-1개를 넘어갈 수 없다는 의미죠. 즉, M의 값이 n+n-1=2n-1이 됩니다.

여기에 맨 처음 mn, mx 값을 구하려면 [0, 1e18] 전체에 대한 쿼리를 날려야겠죠. 이때 n이 추가됩니다. 따라서 M은 3n-1이 됩니다!







한 구간 내에서의 gap은 당연히 하한보다 작기 때문에 신경 쓸 필요가 없습니다!























































































